####
1. cds.read does not work
calling with await cds.read('MovimentiMaster').... gives invalid table name error

correct aproach is srv.run

let aMovimentiMaster = await srv.run(SELECT.from('MovimentiMaster').where({
                    Posizione_IdPosizione: aSoggetti[index].IdPosizione,
                    SchedaFatturazione: null,
                    IDRipartizione: { '!=': null }
                }).orderBy('IDRipartizione asc'));


#### 0 before number
let number = 4;
let paddedNumber = number.toString().padStart(2, '0');
console.log(paddedNumber);  // Output: 04

##### digits format
parseFloat(item.ImportoEsente).toLocaleString('it', { minimumFractionDigits: 2 });

#### excel dateFormat 
oRowBinding.aIndices.forEach(x => {
                    oRowBinding.oList[x].MeseMovimento = new Intl.DateTimeFormat("it-IT", { month: "long" }).format(new Date(oRowBinding.oList[x].DataMovimento))

                    array.push(oRowBinding.oList[x]);
                })

#### excel .csv Cell format
onExport: function () {
                let that = this;
                var aCols, oRowBinding, oSettings, oSheet, oTable;

                let sFileName = "Report Riepilogo CU" + ".xlsx";
                let oWorksheet = [];


                oTable = that.byId("ReportRiepilogoCuTable");
                oRowBinding = oTable.getBinding("items");
                let array = [];
                oRowBinding.aIndices.forEach(x => {
                    delete oRowBinding.oList[x].ID;
                    delete oRowBinding.oList[x].Categoria;
                    delete oRowBinding.oList[x].DataContabile;
                    delete oRowBinding.oList[x].Nazione;
                    delete oRowBinding.oList[x].DareAvere;
                    array.push(oRowBinding.oList[x]);
                })
                array.forEach(item => {
                    item.PercentualeAliquota = parseFloat(item.PercentualeAliquota)/100;
                    item.ImportoEsente = parseFloat(item.ImportoEsente);
                });
                oWorksheet.push(XLSX.utils.json_to_sheet(array, { header: ['TipologiaPercipiente', 'CausaleMovimentazione', 'DescrizioneCausale', 'ImportoLordo', 'ImportoRitenuta', 'ImportoNetto', 'ImportoEsente', 'CodiceRA', 'PercentualeAliquota', 'TipoDiritto', 'TipoRitenuta', 'RitenutaConvenzionale'] }));

                for (const [key, value] of Object.entries(oWorksheet[0])) { // I column PercentualeAliquota
                    if (key.startsWith('I')  && value.t === "n") {
                        value.z = "0.00%";
                    }
                }

                let oWorkbook = {
                    Sheets: {
                        "Report Riepilogo CU": oWorksheet[0],
                    },
                    SheetNames: ["Report Riepilogo CU"]
                };
                XLSX.writeFile(oWorkbook, sFileName);
            },


#### check validity for more than 1000 entries ( entris ipunted from csv)
let distinctPositions = [...new Set(aFile.map(x => x[0]))];
                let batchSize = 1000; // model.read() gives max 1000 rows as a response so this is the max we can check
                // we will seperate distinctPositions in batches and filter AnagraficaPosizioni in parts
                let promises = [];
                for (let i = 0; i < distinctPositions.length; i += batchSize) {
                    let disPosBatch = distinctPositions.slice(i, i + batchSize);
                    let aFilters = disPosBatch.map(function (x) {
                        return new Filter("IdPosizione", FilterOperator.EQ, x);
                    });
                    promises.push(this.apiGet(oModel, '/AnagraficaPosizioni', aFilters));
                }

                let results = await Promise.all(promises);
                let validPos = results.flat().map(x => x.IdPosizione)

                if (validPos.length !== distinctPositions.length) {
                    let set = new Set(validPos);
                    aFile = aFile.filter(x => set.has(x[0]));
                }